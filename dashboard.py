# -*- coding: utf-8 -*-
"""dashboard.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wN0cmr4-w_VOn67LSb-KV4QrlbsWwdtE
"""

# --- Bibliotecas ---
import streamlit as st
import pandas as pd
import joblib
import pickle # Adicionada a importa√ß√£o do pickle
import plotly.express as px

# --- Configura√ß√£o da P√°gina ---
st.set_page_config(
    page_title="Dashboard de Detec√ß√£o de Fraudes",
    page_icon="ü§ñ",
    layout="wide"
)

# --- Fun√ß√µes de Cache ---
@st.cache_data
def load_data(filepath):
    """Carrega o dataset inicial."""
    try:
        # Changed delimiter from ';' to ','
        df = pd.read_csv('/content/drive/MyDrive/Projetos/creditcard.csv', delimiter=',', decimal='.')
        return df
    except FileNotFoundError:
        return None

@st.cache_resource
def load_model(model_format):
    """Carrega o modelo treinado no formato escolhido (.joblib ou .pkl)."""
    if model_format == 'Joblib (.joblib)':
        try:
            model = joblib.load('best_fraud_detection_model.joblib')
            return model
        except FileNotFoundError:
            return None
    elif model_format == 'Pickle (.pkl)':
        try:
            with open('best_fraud_detection_model.pkl', 'rb') as file:
                model = pickle.load(file)
            return model
        except FileNotFoundError:
            return None
    return None

@st.cache_resource
def load_scaler(scaler_path):
    """Carrega o scaler salvo."""
    try:
        scaler = joblib.load(scaler_path)
        return scaler
    except FileNotFoundError:
        return None

# --- Barra Lateral (Sidebar) ---
st.sidebar.title("Navega√ß√£o e Op√ß√µes")

# Adicionado o seletor para escolher o formato do modelo
model_format_choice = st.sidebar.selectbox(
    "Escolha o formato do modelo para carregar:",
    ('Joblib (.joblib)', 'Pickle (.pkl)')
)

page = st.sidebar.radio("Selecione uma p√°gina:", ["Vis√£o Geral", "An√°lise Explorat√≥ria", "Previs√£o de Fraude"])

# --- Carregamento dos Arquivos com base na sele√ß√£o ---
df_raw = load_data('creditcard.csv')
model = load_model(model_format_choice)
scaler = load_scaler('scaler.joblib')

# Checagem de erro se algum arquivo n√£o for encontrado
if df_raw is None or model is None or scaler is None:
    st.error("Erro Cr√≠tico: Arquivo(s) necess√°rio(s) n√£o encontrado(s).")
    st.info("Por favor, execute o script 'preparar_artefatos.py' e verifique se os arquivos 'creditcard_reduzido.csv', '.joblib' e '.pkl' est√£o no mesmo diret√≥rio.")
    st.stop()

# Mensagem de sucesso na barra lateral
st.sidebar.success(f"Modelo '{model_format_choice}' carregado com sucesso.")

# --- L√≥gica das P√°ginas (permanece a mesma) ---

# P√°gina 1: Vis√£o Geral
if page == "Vis√£o Geral":
    st.title("Dashboard Interativo de Detec√ß√£o de Fraudes")
    st.markdown("""
    Este dashboard utiliza um modelo de Machine Learning para analisar e prever fraudes em transa√ß√µes financeiras.
    - **Dados:** Dataset anonimizado de transa√ß√µes com cart√£o de cr√©dito.
    - **Modelo:** LightGBM (Gradient Boosting).
    - **Objetivo:** Identificar transa√ß√µes fraudulentas em tempo real e explorar padr√µes nos dados.
    """)

    st.header("M√©tricas Gerais do Dataset")
    total_transacoes = df_raw.shape[0]
    fraudes = df_raw['Class'].sum()
    taxa_fraude = (fraudes / total_transacoes) * 100

    col1, col2, col3 = st.columns(3)
    col1.metric("Total de Transa√ß√µes", f"{total_transacoes:,}")
    col2.metric("Total de Fraudes", f"{fraudes}")
    col3.metric("Taxa de Fraude", f"{taxa_fraude:.3f}%")

    st.header("Amostra dos Dados")
    st.dataframe(df_raw.head())

# P√°gina 2: An√°lise Explorat√≥ria
elif page == "An√°lise Explorat√≥ria":
    st.title("An√°lise Explorat√≥ria dos Dados")
    st.markdown("Selecione um gr√°fico para explorar os padr√µes das transa√ß√µes.")

    chart_choice = st.selectbox(
        "Escolha o gr√°fico:",
        ["Distribui√ß√£o do Valor (Amount) por Classe", "Distribui√ß√£o do Tempo (Time) por Classe"]
    )

    if chart_choice == "Distribui√ß√£o do Valor (Amount) por Classe":
        fig = px.histogram(df_raw, x="Amount", color="Class", marginal="box",
                           hover_data=df_raw.columns, log_y=True,
                           title="Distribui√ß√£o do Valor da Transa√ß√£o por Classe",
                           labels={"Amount": "Valor da Transa√ß√£o", "Class": "Classe (0: Normal, 1: Fraude)"})
        st.plotly_chart(fig, use_container_width=True)

    elif chart_choice == "Distribui√ß√£o do Tempo (Time) por Classe":
        df_eda = df_raw.copy()
        df_eda['Time_in_Hours'] = df_eda['Time'] / 3600
        fig = px.histogram(df_eda, x="Time_in_Hours", color="Class",
                           title="Distribui√ß√£o das Transa√ß√µes ao Longo do Tempo (em Horas)",
                           labels={"Time_in_Hours": "Tempo em Horas", "Class": "Classe"})
        st.plotly_chart(fig, use_container_width=True)

# P√°gina 3: Previs√£o de Fraude
elif page == "Previs√£o de Fraude":
    st.title("Previs√£o de Fraude em Tempo Real")
    st.markdown("Insira os dados da transa√ß√£o para obter uma previs√£o.")

    important_features = ['V14', 'V12', 'V10', 'V17', 'V4', 'V11', 'V3', 'V7', 'V16']

    with st.form("prediction_form"):
        st.header("Insira os valores das features:")

        cols = st.columns(3)
        input_data = {}

        # Obter colunas de features do dataframe (ap√≥s a limpeza e prepara√ß√£o) para usar como refer√™ncia
        X_columns = df_raw.drop(['Time', 'Amount', 'Class'], axis=1).columns

        for i, feature in enumerate(important_features):
            with cols[i % 3]:
                min_val = float(df_raw[feature].min())
                max_val = float(df_raw[feature].max())
                median_val = float(df_raw[feature].median())
                input_data[feature] = st.slider(f"Valor de {feature}", min_val, max_val, median_val)

        input_data['Amount'] = st.number_input("Valor da Transa√ß√£o (Amount)", min_value=0.0, value=100.0, step=10.0)

        submitted = st.form_submit_button("Realizar Previs√£o")

    if submitted:
        new_transaction = pd.DataFrame([input_data])

        for col in X_columns:
            if col not in new_transaction.columns:
                new_transaction[col] = df_raw[col].median()

        new_transaction['scaled_Amount'] = scaler.transform(new_transaction[['Amount']])
        new_transaction_processed = new_transaction.drop('Amount', axis=1)
        # Garantir a ordem correta das colunas
        new_transaction_processed = new_transaction_processed[X_columns]

        prediction = model.predict(new_transaction_processed)[0]
        probability = model.predict_proba(new_transaction_processed)[0][1]

        st.header("Resultado da Previs√£o")
        if prediction == 1:
            st.error("Previs√£o: TRANSA√á√ÉO FRAUDULENTA", icon="üö®")
        else:
            st.success("Previs√£o: Transa√ß√£o Normal", icon="‚úÖ")

        st.metric("Probabilidade de ser Fraude:", f"{probability:.2%}")

        with st.expander("Ver dados de entrada da previs√£o"):
            st.write(new_transaction_processed)